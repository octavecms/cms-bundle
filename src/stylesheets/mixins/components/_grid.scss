@import "mixins/helpers/browsers";
@import "mixins/lib/strip-unit";
@import "mixins/lib/str-replace";
@import "mixins/lib/is-css-variable";

/*
 * Grid generator mixins
 */

/**
 * Grid row mixin
 */
@mixin grid-row () {
    display: flex;
    flex-wrap: wrap;
}

/**
 * Set gutter
 *
 * @property {number} $gutter Gutter
 * @property {map|null} $namespaces Grid column and offset classnames
 */
@mixin grid-row-pad-gutter ($gutter, $namespaces: null) {
    $selector: if($namespaces and map-has-key($namespaces, columnSelector), map-get($namespaces, columnSelector), '.col');

    @if is-css-variable($gutter) {
        margin-left:  calc(#{ $gutter } * -0.5);
        margin-right: calc(#{ $gutter } * -0.5);
        
        > #{ $selector } {
            padding-left:  calc(#{ $gutter } / 2);
            padding-right: calc(#{ $gutter } / 2);
        }
    } @else {
        margin-left:  ($gutter / -2);
        margin-right: ($gutter / -2);
        
        > #{ $selector } {
            padding-left:  ($gutter / 2);
            padding-right: ($gutter / 2);
        }
    }
}

/**
 * Mixin to generate paddings between grid columns
 *
 * @property {map} $grid-config Grid configuration
 * @property {map|null} $namespaces Grid column and offset classnames
 */
@mixin grid-row-pad ($grid-config, $namespaces: null) {
    // We use last known gutter to make sure value 0 overwrites any
    // previously set value, but at the same time that we don't output
    // unnecessary duplicate code, eg. setting "0" gutter on all breakpoints
    $last-known-gutter-value: 0;

    @each $breakpoint, $config in $grid-config {
        @if map-has-key($config, 'gutter') {
            $gutter: map-get($config, 'gutter');
            $gutter-value: strip-unit($gutter);

            @if $gutter-value or $last-known-gutter-value {
                @if is-valid-media-breakpoint('#{$breakpoint}-up') {
                    @include media-breakpoint('#{$breakpoint}-up') {
                        @include grid-row-pad-gutter($gutter, $namespaces);
                    }
                } @else if is-valid-media-breakpoint('#{$breakpoint}') {
                    @include media-breakpoint('#{$breakpoint}') {
                        @include grid-row-pad-gutter($gutter, $namespaces);
                    }
                }
            }

            $last-known-gutter-value: $gutter-value;
        }
    }
}


/**
 * Generate grid alignment classnames
 *
 * @property {map} $grid-config Grid configuration
 */
@mixin grid-alignment ($grid-config, $namespaces: null) {
    $selector: if($namespaces and map-has-key($namespaces, columnSelectorStyle), map-get($namespaces, columnSelectorStyle), '.col--style');

    @each $breakpoint, $config in $grid-config {
        @include media-breakpoint('#{$breakpoint}-up') {
            // Horizontal alignment, col--start-...
            #{ str-replace($selector, (STYLE: 'start-#{ $beakpoint }')) } {
                justify-content: flex-start;
                text-align: start;
            }

            #{ str-replace($selector, (STYLE: 'center-#{ $beakpoint }')) } {
                justify-content: center;
                text-align: center;
            }
            #{ str-replace($selector, (STYLE: 'end-#{ $beakpoint }')) } {
                justify-content: flex-end;
                text-align: end;
            }

            // Vertical alignment, col--top-...
            #{ str-replace($selector, (STYLE: 'top-#{ $beakpoint }')) } {
                align-items: flex-start;
            }
            #{ str-replace($selector, (STYLE: 'middle-#{ $beakpoint }')) } {
                align-items: center;
            }
            #{ str-replace($selector, (STYLE: 'bottom-#{ $beakpoint }')) } {
                align-items: flex-end;
            }

            // Spacing, col--around-..., .col--between-...
            #{ str-replace($selector, (STYLE: 'around-#{ $beakpoint }')) } {
                justify-content: space-around;
            }
            #{ str-replace($selector, (STYLE: 'between-#{ $beakpoint }')) } {
                justify-content: space-between;
            }

            // Order, col--order-...
            #{ str-replace($selector, (STYLE: 'order-first-#{ $beakpoint }')) } {
                order: -1;
            }
            #{ str-replace($selector, (STYLE: 'order-normal-#{ $beakpoint }')) } {
                order: 0;
            }
            #{ str-replace($selector, (STYLE: 'order-last-#{ $beakpoint }')) } {
                order: 1;
            }
        }
    }
}


/**
 * Mixin to generate column classnames for each resolutions
 *
 * @property {map} $grid-config Grid column configuration
 * @property {map|null} $namespaces Grid column and offset classnames
 */
@mixin grid-columns ($grid-config, $namespaces: null) {
    $col: if($namespaces and map-has-key($namespaces, columnSelector), map-get($namespaces, columnSelector), '.col');

    #{ $col } {
        flex: 1;         // allow growing to accomodate all content, no specific size
        max-width: 100%; // prevent overflowing
    }

    @each $breakpoint, $config in $grid-config {
        @include media-breakpoint('#{$breakpoint}-up') {
            @include grid-columns-breakpoint($config, $breakpoint, $namespaces);
        }
    }
}

@mixin grid-columns-breakpoint ($config, $breakpoint, $namespaces: null) {
    $colSelector: if($namespaces and map-has-key($namespaces, columnSelectorSize), map-get($namespaces, columnSelectorSize), '.col--BREAKPOINT-SIZE');
    $offsetSelector: if($namespaces and map-has-key($namespaces, columnSelectorOffset), map-get($namespaces, columnSelectorOffset), '.offset--BREAKPOINT-SIZE');

    $col: if($namespaces and map-has-key($namespaces, column), map-get($namespaces, column), '.col');
    $offset: if($namespaces and map-has-key($namespaces, offset), map-get($namespaces, offset), '.offset');

    $columns: map-get($config, 'columns');
    $unit: map-get($config, 'unit');

    @if not $unit {
        $unit: 100%;
    } @else if unitless($unit) {
        @error "Grid column width can't be without a unit \"#{ $unit }\", please add unit, eg. \"#{ $unit * 1% }\", \"#{ $unit * 1vw }\"";
    }

    @if $columns {
        @for $i from 1 through $columns {
            $width: $i / $columns * $unit;

            #{ str-replace($colSelector, (BREAKPOINT: $breakpoint, SIZE: $i)) } {
                @include grid-column($width);
            }

            #{ str-replace($offsetSelector, (BREAKPOINT: $breakpoint, SIZE: $i)) } {
                @include grid-offset($width);
            }
        }

        #{ str-replace($colSelector, (BREAKPOINT: $breakpoint, SIZE: 'full')) } {
            @include grid-column(100%);
        }
        #{ str-replace($offsetSelector, (BREAKPOINT: $breakpoint, SIZE: 0)) } {
            @include grid-offset(0);
        }
    }

    // Custom column widths
    $custom: map-get($config, 'custom');

    @if $custom and type-of($custom) == 'map' {
        @each $name, $width in $custom {
            #{ str-replace($colSelector, (BREAKPOINT: $breakpoint, SIZE: $name)) } {
                @include grid-column($width);
            }
            #{ str-replace($offsetSelector, (BREAKPOINT: $breakpoint, SIZE: $name)) } {
                @include grid-offset($width);
            }
        }
    }

    // Column wihch takes as little space as needed
    #{ str-replace($colSelector, (BREAKPOINT: $breakpoint, SIZE: 'auto')) } {
        @include grid-column-auto($unit);
    }

    // Column fills all available space
    #{ str-replace($colSelector, (BREAKPOINT: $breakpoint, SIZE: 'fill')) } {
        @include grid-column-fill($unit);
    }
}


/**
 * Fix for vw units 16.667 -> 16.66
 * Needed to prevent columns inside the columns from wrapping
 */

@function grid-column-precision-fix ($width) {
    @if unit($width) == 'vw' {
        $unit: ($width - $width + 1);
        $width-str: "#{ $width }";
        $dot-index: str-index($width-str, '.');

        @if $dot-index and str-length($width-str) - $dot-index > 4 {
            $width-str: str-slice($width-str, 1, $dot-index + 4);
            @return str-to-number($width-str) * $unit;
        } @else {
            @return $width;
        }
    } @else {
        @return $width;
    }
}


/*
 * 1. Fix for IE where paddings are not taken into account even with box-sizing
 * 2. Fix for Firefox, if content is larger than grid item then grid element extends
 */

@mixin grid-column ($width) {
    $width-fixed: grid-column-precision-fix($width);

    flex: 0 1 $width-fixed;
    width: $width-fixed;

    @include browser-firefox() {
        max-width: $width-fixed; // 2.
    }
}

@mixin grid-offset ($width) {
    $width-fixed: grid-column-precision-fix($width);
    margin-left: $width-fixed;
}

/**
 * Grid column which takes as specific size
 *
 * @property {number} $width Column width
 */
@mixin grid-column-fixed ($width) {
    flex: 0 0 $width;
    width: $width;

    @include browser-firefox() {
        max-width: $width; // 2.
    }
}

/**
 * Grid column which takes as little space as necessery
 *
 * @property {number} $unit Grid unit, default `100%`
 */
@mixin grid-column-auto ($unit: 100%) {
    flex: 0 0 auto;
    width: auto;

    @include browser-firefox() {
        max-width: none;
    }
}

/**
 * Grid column which takes all available space
 *
 * @property {number} $unit Grid unit, default `100%`
 */
@mixin grid-column-fill ($unit: 100%) {
    flex: 1 1 auto;
    width: auto;

    @include browser-firefox() {
        max-width: none;
    }
}
